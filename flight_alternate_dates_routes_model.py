# -*- coding: utf-8 -*-
"""flight_alternate_dates_routes_model.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Zhrs9z3Zq6ZZyOzC_fDX9lyOcPYDf3AX
"""

import pandas as pd
import numpy as np
from sklearn.preprocessing import LabelEncoder

df = pd.read_csv("C:\\Users\\parag\\Downloads\\flight-api\\oneway_new.csv")
print("Dataset loaded. Shape:", df.shape)
df.head()

url = "https://raw.githubusercontent.com/jpatokal/openflights/master/data/airports.dat"
cols = ["Airport_ID", "Name", "City", "Country", "IATA", "ICAO",
        "Latitude", "Longitude", "Altitude", "Timezone", "DST", "Tz", "Type", "Source"]

df_airports = pd.read_csv(url, header=None, names=cols)
df_airports = df_airports[df_airports["IATA"].notnull() & (df_airports["IATA"] != "\\N")]
df_airports = df_airports[["IATA", "Name", "City", "Country", "Latitude", "Longitude"]]

extra_airports = {
    "XNB": (25.2654, 55.3086),
    "BER": (52.3667, 13.5033)
}

for code, (lat, lon) in extra_airports.items():
    df_airports = pd.concat([df_airports, pd.DataFrame([[code, code, "", "", lat, lon]],
                            columns=["IATA","Name","City","Country","Latitude","Longitude"])])

from sklearn.cluster import DBSCAN

coords = np.radians(df_airports[["Latitude", "Longitude"]].values)
clustering = DBSCAN(eps=50/6371, min_samples=1, metric="haversine").fit(coords)
df_airports["cluster"] = clustering.labels_
cluster_map = dict(zip(df_airports["IATA"], df_airports["cluster"]))

df["Dep_Date"] = pd.to_datetime(df["Dep_Date"])
df["Month"] = df["Dep_Date"].dt.month
df["DayOfWeek"] = df["Dep_Date"].dt.dayofweek
df["Hour"] = df["Dep_Date"].dt.hour
df["is_weekend"] = df["DayOfWeek"].isin([5,6]).astype(int)

def get_season(month):
    if month in [12,1,2]: return "Winter"
    elif month in [3,4,5]: return "Spring"
    elif month in [6,7,8]: return "Summer"
    else: return "Fall"
df["Season"] = df["Month"].apply(get_season)

df.head(2)

df["Dep_Cluster"] = df["Dep_Code"].map(cluster_map).fillna(-1)
df["Arr_Cluster"] = df["Arr_Code"].map(cluster_map).fillna(-1)
df["same_cluster_route"] = (df["Dep_Cluster"] == df["Arr_Cluster"]).astype(int)

df["route_length"] = df["totaltime"] / (df["flightstops"]+1)

from sklearn.preprocessing import OneHotEncoder, LabelEncoder

ohe = OneHotEncoder(handle_unknown="ignore", sparse_output=False)

ohe_features = ohe.fit_transform(df[["Dep_Code", "Arr_Code", "airline", "baggage","triptype"]])
ohe_feature_names = ohe.get_feature_names_out(["Dep_Code", "Arr_Code", "airline", "baggage","triptype"])

df_ohe = pd.DataFrame(ohe_features, columns=ohe_feature_names, index=df.index)

le = LabelEncoder()
df["Season_enc"] = le.fit_transform(df["Season"])

df_final = pd.concat([
    df.drop(columns=["Dep_Code","Arr_Code","airline","baggage","Season","triptype"]),
    df_ohe,
    df[["Season_enc"]]
], axis=1)

df_final = df_final.drop(columns=["Arr_Date", "Scrap_Date","Dep_Date"])


print("Final feature set shape:", df_final.shape)
df_final.head()

from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import root_mean_squared_error, r2_score , mean_absolute_error
import numpy as np

X = df_final.drop(columns=["price"])
y = df_final["price"]

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

rf = RandomForestRegressor(
    n_estimators=150,
    max_depth=20,
    random_state=42,
    n_jobs=-1
)
rf.fit(X_train, y_train)

y_pred = rf.predict(X_test)

rmse = root_mean_squared_error(y_test, y_pred)
mae = mean_absolute_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)

print("Model trained successfully")
print("RMSE:", rmse)
print("MAE:", mae)
print("R² Score:", r2)

import joblib

import joblib
joblib.dump(rf, "flight_price_model.pkl",compress=3)


joblib.dump(ohe, "onehot_encoder.pkl")

joblib.dump(le, "season_labelencoder.pkl")

import pandas as pd

def predict_price(user_input, model, feature_cols, encoders, df):
    """
    Predicts price (£) for a given flight input dict.
    user_input = {"Dep_Code": "DEL", "Arr_Code": "DXB", "airline": "AI", "Dep_Date": "2025-08-29"}
    """

    match = df[
        (df["Dep_Code"] == user_input["Dep_Code"]) &
        (df["Arr_Code"] == user_input["Arr_Code"]) &
        (df["airline"] == user_input["airline"])
    ].head(1)

    if match.empty:
        match = df[
            (df["Dep_Code"] == user_input["Dep_Code"]) &
            (df["airline"] == user_input["airline"])
        ].head(1)

    if match.empty:
        match = df[df["airline"] == user_input["airline"]].head(1)

    if match.empty:
        match = df.head(1)

    temp_df = match.copy()
    for key, val in user_input.items():
        temp_df[key] = val

    temp_df["Dep_Date"] = pd.to_datetime(temp_df["Dep_Date"])
    temp_df["DayOfWeek"] = temp_df["Dep_Date"].dt.dayofweek
    temp_df["Month"] = temp_df["Dep_Date"].dt.month
    temp_df["Hour"] = temp_df["Dep_Date"].dt.hour
    temp_df["is_weekend"] = temp_df["DayOfWeek"].isin([5, 6]).astype(int)

    if isinstance(encoders, dict):
        for col, encoder in encoders.items():
            if col in temp_df:
                temp_df[col] = encoder.transform(temp_df[[col]])
    else:
        cat_cols = encoders.feature_names_in_
        if all(col in temp_df.columns for col in cat_cols):
            encoded = encoders.transform(temp_df[cat_cols])
            encoded_df = pd.DataFrame(
                encoded,
                columns=encoders.get_feature_names_out(cat_cols),
                index=temp_df.index
            )
            temp_df = pd.concat([temp_df.drop(columns=cat_cols), encoded_df], axis=1)

    temp_df = temp_df.reindex(columns=feature_cols, fill_value=0)

    pred = model.predict(temp_df)[0]
    return float(pred)

def suggest_alternatives(user_input, df, model, feature_cols, encoders, cluster_map, df_airports, top_k=5, return_df=True):
    """
    Suggest cheaper alternatives based on:
      - Nearby arrival/departure airports (any airline & same date)
      - Alternate dates (same route & airline, only if airline given)
    """

    def adjusted_prediction(uinput):
        """Predict price but clamp it to dataset min/max for that airline+route."""
        pred_price = predict_price(uinput, model, feature_cols, encoders, df)

        mask = (
            (df["Dep_Code"] == uinput["Dep_Code"]) &
            (df["Arr_Code"] == uinput["Arr_Code"])
        )
        if uinput["airline"]:  # only filter by airline if provided
            mask &= (df["airline"] == uinput["airline"])

        subset = df[mask]

        if not subset.empty:
          min_price, max_price = subset["price"].min(), subset["price"].max()
          if pred_price < min_price or pred_price > max_price:
             pred_price = subset["price"].mean()

        return pred_price


    dep = user_input["Dep_Code"]
    arr = user_input["Arr_Code"]
    airline = user_input.get("airline", None)   # optional now
    dep_date = pd.to_datetime(user_input["Dep_Date"])

    suggestions = []

    # ========= BASE PRICE =========
    if airline:
        # predict for specific airline
        base_price = adjusted_prediction(user_input)
        base_info = [[dep, arr, airline, f"£{base_price:,.0f}", "—", "Base Search"]]
    else:
        # no airline → compute for all airlines on this route/date
        same_date_flights = df[
            (df["Dep_Code"] == dep) &
            (df["Arr_Code"] == arr) &
            (pd.to_datetime(df["Dep_Date"]).dt.date == dep_date.date())
        ]
        if same_date_flights.empty:
            print(f"No flights found for {dep}->{arr} on {dep_date.date()}")
            return None

        results = []
        for al in same_date_flights["airline"].unique():
            uinput_copy = user_input.copy()
            uinput_copy["airline"] = al
            price = adjusted_prediction(uinput_copy)
            results.append([dep, arr, al, f"£{price:,.0f}", "—", "Base Search"])
        # sort cheapest first
        results = sorted(results, key=lambda x: float(x[3].replace("£", "").replace(",", "")))
        base_price = float(results[0][3].replace("£", "").replace(",", ""))  # use cheapest as baseline
        base_info = results

    # ========= ALTERNATE ROUTES (nearby dep/arr, ANY airline) =========
    if dep in cluster_map and arr in cluster_map:
        dep_cluster = cluster_map[dep]
        arr_cluster = cluster_map[arr]

        nearby_deps = df_airports[df_airports["cluster"] == dep_cluster]["IATA"].unique()
        nearby_arrs = df_airports[df_airports["cluster"] == arr_cluster]["IATA"].unique()

        for alt_dep in nearby_deps:
            for alt_arr in nearby_arrs:
                if alt_dep == dep and alt_arr == arr:
                    continue

                same_date_flights = df[
                    (df["Dep_Code"] == alt_dep) &
                    (df["Arr_Code"] == alt_arr) &
                    (pd.to_datetime(df["Dep_Date"]).dt.date == dep_date.date())
                ]
                if same_date_flights.empty:
                    continue

                cheapest = same_date_flights.loc[same_date_flights["price"].idxmin()]
                alt_input = {
                    "Dep_Code": cheapest["Dep_Code"],
                    "Arr_Code": cheapest["Arr_Code"],
                    "airline": cheapest["airline"],
                    "Dep_Date": dep_date.strftime("%Y-%m-%d")
                }

                alt_price = adjusted_prediction(alt_input)
                savings = base_price - alt_price
                savings_pct = (savings / base_price) * 100 if base_price > 0 else 0

                suggestions.append([
                    alt_dep, alt_arr, cheapest["airline"],
                    f"£{alt_price:,.0f}",
                    f"£{savings:,.0f} ({savings_pct:.1f}%)" if savings > 0 else "—",
                    "Alternate route"
                ])

    # ========= ALTERNATE DATES (only if airline given) =========
    if airline:
        for offset in range(-7, 8):
            if offset == 0:
                continue
            try:
                alt_date = dep_date + pd.Timedelta(days=offset)
                alt_input = user_input.copy()
                alt_input["Dep_Date"] = alt_date.strftime("%Y-%m-%d")

                exists = df[
                    (df["Dep_Code"] == dep) &
                    (df["Arr_Code"] == arr) &
                    (df["airline"] == airline) &
                    (pd.to_datetime(df["Dep_Date"]).dt.date == alt_date.date())
                ]
                if exists.empty:
                    continue

                alt_price = adjusted_prediction(alt_input)
                savings = base_price - alt_price
                savings_pct = (savings / base_price) * 100 if base_price > 0 else 0
                suggestions.append([
                    dep, arr, airline,
                    f"£{alt_price:,.0f}",
                    f"£{savings:,.0f} ({savings_pct:.1f}%)" if savings > 0 else "—",
                    f"Alternate date ({alt_date.strftime('%Y-%m-%d')})"
                ])
            except ValueError:
                continue

    # ========= SORT & RETURN =========
    suggestions = sorted(
        suggestions,
        key=lambda x: float(x[3].replace("£", "").replace(",", ""))
    )[:top_k]

    if return_df:
        df_out = pd.DataFrame(
            base_info + suggestions,
            columns=["Departure", "Arrival", "Airline", "Predicted Price", "Savings", "Reason"]
        )
        return df_out

    return {
        "Base Search": base_info,
        "Alternatives": suggestions
    }

def create_cluster_map(df_airports):
    return dict(zip(df_airports["IATA"], df_airports["cluster"]))

from datetime import datetime

from datetime import datetime
if __name__ == "__main__":

 dep_code = input("Enter Departure Airport Code (e.g. DEL): ").strip().upper()
 arr_code = input("Enter Arrival Airport Code (e.g. DXB): ").strip().upper()
 date_str = input("Enter Departure Date (YYYY-MM-DD): ").strip()
 airline = input("Enter Airline Code (optional, press Enter to skip): ").strip().upper() or None

# validate date
 try:
     dep_date = datetime.strptime(date_str, "%Y-%m-%d").strftime("%Y-%m-%d")
 except ValueError:
     raise ValueError("Invalid date format! Please use YYYY-MM-DD")

 user_input = {
    "Dep_Code": dep_code,
    "Arr_Code": arr_code,
    "Dep_Date": dep_date,
    "airline": airline
 }


 df_results = suggest_alternatives(
    user_input,
    df,
    rf,
    X_train.columns,
    ohe,
    cluster_map,
    df_airports,
    top_k=5,
    return_df=True
 )

 print("\n===== Flight Price Suggestions =====")
 print(df_results.to_string(index=False))

